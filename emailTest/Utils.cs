using System;
using System.Collections.Generic;
using System.Data;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text.RegularExpressions;

namespace emailTest
{
    class Utils
    {
        private const string RESULTS_DIRECROTY_NAME = "TempResults";

        public static string resultsDirectoryPath = string.Empty;

        // function deletes 'old' results folder with all it's files and creates one new
        // results folder is needed for autogenerated excel files for mail attachments
        public static void createResultsFolder()
        {
            // create results folder for the temp filtered excel files
            resultsDirectoryPath = Path.Combine(Directory.GetCurrentDirectory(), RESULTS_DIRECROTY_NAME);

            try
            {
                if (Directory.Exists(resultsDirectoryPath))
                {
                    Directory.Delete(resultsDirectoryPath, true);
                }

                Directory.CreateDirectory(resultsDirectoryPath);
            }
            catch (Exception e)
            {
                // fatal: cannot continue
                OrdersParser._Form.log(string.Format("Failed to create/delete results folder {0}. Error: {1}", resultsDirectoryPath, e.Message), OrdersParser.logLevel.error);
                return;
            }
        }

        // function kiils all processes of a given name
        public static void killProcess(string processName)
        {
            foreach (var process in Process.GetProcessesByName(processName))
            {
                try
                {
                    process.Kill();
                }
                catch(Exception e)
                {
                    OrdersParser._Form.log(string.Format("Failed to kill process {0}. Error: {1}", processName, e.Message), OrdersParser.logLevel.error);
                }
            }
        }

        // function translates date as string into DateTime IL format
        public static DateTime getDateFromDynamicSheet(dynamic value)
        {
            DateTime val = DateTime.MinValue;

            try
            {
                // note: IL format
                val = DateTime.ParseExact(value, Common.DATE_FORMAT, CultureInfo.InvariantCulture);
            }
            catch (Exception e)
            {
                // empty cell or could't parse
                OrdersParser._Form.log(string.Format("Failed to parse date. val: {0}, error: {1}", value, e.Message), OrdersParser.logLevel.error);
            };

            return val;
        }

        // function parses returns string for any read value
        // in case of null, empty string is returned
        public static string getStringFromDynamicSheet(string value)
        {
            string val = string.Empty;

            try
            {
                val = value.Trim();
            }
            catch
            {
                // empty cell
            };

            return val;
        }

        // function converts column name (letter) to index
        // e.g. A -> 1, B -> 2, ..
        public static int getIndexFromColumnChar(char column)
        {
            return (Convert.ToInt32(column) - Convert.ToInt32('A') + 1);
        }

        // function generates table (for excel) from a given list of type
        public static object[,] generateObjectFromList<T>(List<T> resultList, out int rows, out int cols)
        {
            FieldInfo[] fields = typeof(T).GetFields(BindingFlags.Public | BindingFlags.Instance);

            // fill out parameters
            // table has one additional row for titles
            rows = resultList.Count + 1;
            cols = fields.Length;

            object[,] table = new object[rows, cols];
            string str = string.Empty;
            int rowOffset = 1;
            int row = 0;

            // fill the column names in the first row
            for (int col = 0; col < fields.Length; col++)
            {
                // setting column names as fields names
                table[0, col] = fields[col].Name;
            }

            // start from the second row
            foreach (T res in resultList)
            {
                for (int col = 0; col < fields.Length; col++)
                {
                    // for DateTime, leave only time in IL format
                    if (fields[col].FieldType.Equals(typeof(DateTime)))
                    {
                        // date format must be with dots, otherwise it gets messy in excel
                        table[row + rowOffset, col] = ((DateTime)(fields[col].GetValue(res))).ToString("dd.MM.yyyy");
                        continue;
                    }

                    // replace 'null' with empty string
                    if ((fields[col].FieldType.Equals(typeof(String))) && (string.IsNullOrEmpty((string)fields[col].GetValue(res)) == true))
                    {
                        table[row + rowOffset, col] = string.Empty;
                        continue;
                    }

                    // else
                    table[row + rowOffset, col] = fields[col].GetValue(res);
                }

                // go to next entry
                row++;
            }

            return table;
        }

        // function generates DataTable from a given list of type
        public static DataTable generateDataTableFromList<T>(List<T> resultList)
        {
            FieldInfo[] fields  = typeof(T).GetFields(BindingFlags.Public | BindingFlags.Instance);
            DataTable   table   = new DataTable();

            // fill the column names in the first row
            for (int col = 0; col < fields.Length; col++)
            {
                // setting column names as fields names
                table.Columns.Add(fields[col].Name);
            }

            // go over all the values in the list
            foreach (T res in resultList)
            {
                var values = new object[fields.Length];

                for (int col = 0; col < fields.Length; col++)
                {
                    // for DateTime, leave only time in IL format
                    if (fields[col].FieldType.Equals(typeof(DateTime)))
                    {
                        // date format must be with dots, otherwise it gets messy in excel
                        values[col] = ((DateTime)(fields[col].GetValue(res))).ToString("dd.MM.yyyy");
                        continue;
                    }

                    // replace 'null' with empty string
                    if ((fields[col].FieldType.Equals(typeof(String))) && (string.IsNullOrEmpty((string)fields[col].GetValue(res)) == true))
                    {
                        values[col] = string.Empty;
                        continue;
                    }

                    // else
                    values[col] = fields[col].GetValue(res);
                }

                // add the value
                table.Rows.Add(values);
            }

            return table;
        }

        // function gets a text and replaces all the parameters in the following format:
        // ({param1}, {param2} ..) by values from a dictionary
        // assumption: dictionary has values for all provided parameters
        public static string extractParameterFromDictionary(string text, Dictionary<string, string> bodyParameters)
        {
            return Regex.Replace(text,
                                 @"\{(\w+)\}", // replaces any text surrounded by { and }
                                 m =>
                                 {
                                     string value;
                                     return bodyParameters.TryGetValue(m.Groups[1].Value, out value) ? value : "null";
                                 });
        }

        // function return the embeded resource name based on the mail type
        // each mail type has body template saved as embeded resource
        public static string getResourceNameFromMailType(Common.MailType mailType)
        {
            switch (mailType)
            {
                case Common.MailType.Reports:
                    {
                        return Anko.Properties.Resources.OrdersMail;
                    }
                case Common.MailType.LoadingConfirmation:
                    {
                        return Anko.Properties.Resources.LoadingConfirmationMail;
                    }
                case Common.MailType.BookingConfirmation:
                    {
                        return Anko.Properties.Resources.BookingConfirmationMail;
                    }
                case Common.MailType.DocumentsReceipts:
                    {
                        return Anko.Properties.Resources.DocumentsReceipts;
                    }
                default:
                    OrdersParser._Form.log("Unrecognized mail type - cannot find mail template", OrdersParser.logLevel.error);
                    return string.Empty;
            }
        }

        // function checks whether text is HEB or EN
        // one char is enough for a text to be HEB
        public static bool isHebrewText(string text)
        {
            char firstHebChar = (char)1488; // א
            char lastHebChar  = (char)1514; // ת

            foreach (char c in text.ToCharArray())
            {
                if (c >= firstHebChar && c <= lastHebChar) return true;
            }

            return false;
        }

        // function capitilizes the first char - for better tables representation
        public static string uppercaseFirst(string text)
        {
            if (string.IsNullOrEmpty(text) == true)
            {
                return string.Empty;
            }

            // return char and concat substring.
            return char.ToUpper(text[0]) + text.Substring(1);
        }
    }
}
